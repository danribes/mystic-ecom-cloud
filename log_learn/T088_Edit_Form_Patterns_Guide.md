# Edit Form Patterns Guide

**Learning Objective**: Master the patterns and best practices for building edit forms that pre-fill, validate, and update existing data.

**Skill Level**: Intermediate  
**Prerequisites**: HTML forms, TypeScript, Astro basics  
**Related Tasks**: T088 (Event Edit Form), T068 (Course Edit Form), T087 (Event Create Form)

---

## Table of Contents

1. [Edit vs Create Forms](#edit-vs-create)
2. [Server-Side Data Fetching](#data-fetching)
3. [Pre-filling Form Fields](#pre-filling)
4. [Type Conversion Patterns](#type-conversion)
5. [Date and Time Handling](#datetime)
6. [Smart Form Logic for Edits](#smart-logic)
7. [Validation with Existing Data](#validation)
8. [API Update Patterns](#api-updates)
9. [Error Handling](#error-handling)
10. [Testing Edit Forms](#testing)
11. [Best Practices](#best-practices)

---

## 1. Edit vs Create Forms {#edit-vs-create}

### Key Differences

| Aspect | Create Form | Edit Form |
|--------|-------------|-----------|
| **Initial State** | Empty fields | Pre-filled with existing data |
| **Data Source** | None | Database/API fetch |
| **URL Pattern** | `/resource/new` | `/resource/[id]/edit` |
| **HTTP Method** | POST | PUT or PATCH |
| **ID Handling** | Generated by server | From URL params |
| **Auto-Generation** | Always active | Conditional |
| **Validation** | All new data | Consider existing state |
| **Error Redirect** | Generic error page | Back to list with message |

### When to Build Which

**Create Form**:
- Adding new records
- No existing data to reference
- Fresh state

**Edit Form**:
- Modifying existing records
- Need to show current values
- Preserve relationships (e.g., bookings)

**Hybrid Approach**:
- Single form component
- Conditional logic based on presence of ID
- More complex but DRY

---

## 2. Server-Side Data Fetching {#data-fetching}

### Fetching in Astro SSR

**Pattern**:
```typescript
---
import { getSessionFromRequest } from '@/lib/auth/session';
import { getResourceById } from '@/lib/resources';

export const prerender = false; // Enable SSR

// 1. Authenticate
const session = await getSessionFromRequest(Astro.cookies);
if (!session) {
  const currentPath = encodeURIComponent(Astro.url.pathname);
  return Astro.redirect(`/login?redirect=${currentPath}`);
}

// 2. Get ID from URL
const { id } = Astro.params;
if (!id) {
  return Astro.redirect('/admin/resources');
}

// 3. Fetch data
let resource;
try {
  resource = await getResourceById(id);
} catch (error) {
  console.error('Error fetching resource:', error);
  return Astro.redirect('/admin/resources?error=not_found');
}
---

<Layout title={`Edit: ${resource.title}`}>
  <!-- Form uses 'resource' data -->
</Layout>
```

### Error Handling in SSR

**Redirect on Error**:
```typescript
try {
  resource = await getResourceById(id);
} catch (error) {
  if (error instanceof NotFoundError) {
    return Astro.redirect('/admin/resources?error=not_found');
  }
  if (error instanceof UnauthorizedError) {
    return Astro.redirect('/login?error=unauthorized');
  }
  // Generic error
  return Astro.redirect('/admin/resources?error=server_error');
}
```

**Why Redirect Instead of Error Page**:
- Better UX (back to known context)
- Preserve user workflow
- Show contextual error message
- Avoid blank error screens

### Query String Error Display

```typescript
// In list page
const url = new URL(Astro.url);
const error = url.searchParams.get('error');

const errorMessages: Record<string, string> = {
  not_found: 'Resource not found',
  unauthorized: 'You do not have permission',
  server_error: 'Something went wrong'
};

const errorMessage = error ? errorMessages[error] : null;
```

```html
{errorMessage && (
  <div class="bg-red-50 border border-red-200 p-4 rounded">
    <p class="text-red-800">{errorMessage}</p>
  </div>
)}
```

---

## 3. Pre-filling Form Fields {#pre-filling}

### Text Inputs

**Simple**:
```html
<input 
  type="text"
  name="title"
  value={resource.title}
/>
```

**With Escaping** (automatic in Astro):
```html
<input 
  type="text"
  value={resource.description}  <!-- Astro auto-escapes -->
/>
```

### Textarea

**Content Between Tags**:
```html
<textarea name="description">{resource.description}</textarea>
```

**NOT** in value attribute:
```html
<!-- ❌ Wrong -->
<textarea value={resource.description}></textarea>
```

### Number Inputs

**Type Conversion**:
```html
<input 
  type="number"
  name="price"
  value={typeof resource.price === 'string' ? parseFloat(resource.price) : resource.price}
/>
```

**Why Handle Both Types**:
- PostgreSQL may return DECIMAL as string
- MySQL may return as number
- JSON APIs return numbers
- Handle all cases defensively

### Select Dropdowns

**Pre-select Option**:
```html
<select name="level">
  <option value="">Select Level</option>
  <option value="beginner" selected={resource.level === 'beginner'}>
    Beginner
  </option>
  <option value="intermediate" selected={resource.level === 'intermediate'}>
    Intermediate
  </option>
  <option value="advanced" selected={resource.level === 'advanced'}>
    Advanced
  </option>
</select>
```

**With Array Mapping**:
```typescript
const levels = ['beginner', 'intermediate', 'advanced'];
```

```html
<select name="level">
  {levels.map(level => (
    <option value={level} selected={resource.level === level}>
      {level.charAt(0).toUpperCase() + level.slice(1)}
    </option>
  ))}
</select>
```

### Checkboxes

**Boolean Binding**:
```html
<input 
  type="checkbox"
  name="is_published"
  checked={resource.is_published}
/>
```

**Multiple Checkboxes** (array):
```typescript
const tags = ['meditation', 'mindfulness', 'yoga'];
```

```html
{tags.map(tag => (
  <label>
    <input 
      type="checkbox"
      name="tags"
      value={tag}
      checked={resource.tags?.includes(tag)}
    />
    {tag}
  </label>
))}
```

### Radio Buttons

```html
<label>
  <input 
    type="radio"
    name="status"
    value="draft"
    checked={resource.status === 'draft'}
  />
  Draft
</label>
<label>
  <input 
    type="radio"
    name="status"
    value="published"
    checked={resource.status === 'published'}
  />
  Published
</label>
```

---

## 4. Type Conversion Patterns {#type-conversion}

### String to Number

**Price (Decimal)**:
```typescript
function parsePrice(value: string | number): number {
  if (typeof value === 'number') return value;
  const parsed = parseFloat(value);
  if (isNaN(parsed)) throw new Error('Invalid price');
  return parsed;
}
```

**Integer**:
```typescript
function parseInteger(value: string | number): number {
  if (typeof value === 'number') return Math.floor(value);
  const parsed = parseInt(value, 10);
  if (isNaN(parsed)) throw new Error('Invalid integer');
  return parsed;
}
```

### Handling Optional Numbers

**Pattern**:
```typescript
function parseOptionalNumber(value: string | number | null | undefined): number | undefined {
  if (value === null || value === undefined || value === '') {
    return undefined;
  }
  
  if (typeof value === 'number') {
    return value;
  }
  
  const parsed = parseFloat(value);
  return isNaN(parsed) ? undefined : parsed;
}
```

**Usage**:
```html
<input 
  type="number"
  name="latitude"
  value={parseOptionalNumber(resource.latitude) ?? ''}
/>
```

**Why Empty String Fallback**:
- `value={undefined}` shows "undefined" in input
- `value={null}` shows "null" in input
- `value={''}` shows empty (correct)

### Array to String

**Tags (comma-separated)**:
```typescript
const tagsString = resource.tags?.join(', ') || '';
```

```html
<input 
  type="text"
  name="tags"
  value={tagsString}
  placeholder="meditation, mindfulness, etc."
/>
```

**Parse Back to Array**:
```typescript
const tags = formData.get('tags')
  ?.split(',')
  .map(tag => tag.trim())
  .filter(Boolean) || [];
```

### Array to Textarea (Line-separated)

**Learning Outcomes**:
```typescript
const outcomesText = resource.learningOutcomes?.join('\n') || '';
```

```html
<textarea name="learning_outcomes">{outcomesText}</textarea>
```

**Parse Back**:
```typescript
const outcomes = formData.get('learning_outcomes')
  ?.split('\n')
  .map(line => line.trim())
  .filter(Boolean) || [];
```

---

## 5. Date and Time Handling {#datetime}

### Database to datetime-local Input

**The Challenge**:
- Database: ISO 8601 string with timezone (e.g., `2024-12-15T18:30:00.000Z`)
- HTML Input: `datetime-local` requires `YYYY-MM-DDTHH:mm` format (no timezone, no seconds)

**Conversion Function**:
```typescript
function formatDateTimeLocal(date: Date | string): string {
  const d = typeof date === 'string' ? new Date(date) : date;
  
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  const hours = String(d.getHours()).padStart(2, '0');
  const minutes = String(d.getMinutes()).padStart(2, '0');
  
  return `${year}-${month}-${day}T${hours}:${minutes}`;
}
```

**Usage**:
```typescript
const formattedDate = formatDateTimeLocal(resource.event_date);
```

```html
<input 
  type="datetime-local"
  name="event_date"
  value={formattedDate}
/>
```

### datetime-local to ISO String

**Client-Side Conversion**:
```typescript
const dateInput = formData.get('event_date') as string;
const isoString = new Date(dateInput).toISOString();
```

**Example**:
```typescript
// Input: "2024-12-15T18:30"
// Output: "2024-12-15T18:30:00.000Z"
```

### Date-Only Inputs

**For `type="date"`**:
```typescript
function formatDate(date: Date | string): string {
  const d = typeof date === 'string' ? new Date(date) : date;
  
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  
  return `${year}-${month}-${day}`;
}
```

```html
<input 
  type="date"
  name="start_date"
  value={formatDate(resource.startDate)}
/>
```

### Time-Only Inputs

**For `type="time"`**:
```typescript
function formatTime(date: Date | string): string {
  const d = typeof date === 'string' ? new Date(date) : date;
  
  const hours = String(d.getHours()).padStart(2, '0');
  const minutes = String(d.getMinutes()).padStart(2, '0');
  
  return `${hours}:${minutes}`;
}
```

```html
<input 
  type="time"
  name="start_time"
  value={formatTime(resource.startTime)}
/>
```

### Timezone Considerations

**Server Stores UTC**:
```typescript
// Database: 2024-12-15T18:30:00.000Z (UTC)
// User in PST sees: 2024-12-15T10:30 (local)
// User in EST sees: 2024-12-15T13:30 (local)
```

**Best Practice**:
1. Store all dates in UTC (database)
2. Convert to local timezone for display (browser does this)
3. Convert back to UTC for storage (server)

---

## 6. Smart Form Logic for Edits {#smart-logic}

### Conditional Auto-Generation

**Problem**: Create forms auto-generate slugs, but edit forms shouldn't overwrite custom slugs.

**Solution**: Track if slug matches auto-generated pattern

```javascript
const titleInput = document.getElementById('title');
const slugInput = document.getElementById('slug');

function generateSlug(text) {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '');
}

// Store original title
titleInput.dataset.previousValue = titleInput.value;

titleInput.addEventListener('input', () => {
  const currentSlug = slugInput.value;
  const previousAutoSlug = generateSlug(titleInput.dataset.previousValue || '');
  
  // Only update if slug appears to be auto-generated (not custom)
  if (!currentSlug || currentSlug === previousAutoSlug) {
    slugInput.value = generateSlug(titleInput.value);
  }
  
  // Update previous value for next comparison
  titleInput.dataset.previousValue = titleInput.value;
});
```

**Flow**:
1. User has event: "Yoga Session" → slug: "yoga-session"
2. User edits title to "Advanced Yoga"
3. Slug matches auto-generated pattern → Update to "advanced-yoga" ✅

**Flow 2**:
1. User has event: "Yoga Session" → slug: "special-yoga" (custom)
2. User edits title to "Advanced Yoga"
3. Slug doesn't match pattern → Keep "special-yoga" ✅

### No Auto-Sync for Related Fields

**Create Form** (T087):
```javascript
// Capacity changes → Available spots auto-updates
capacityInput.addEventListener('input', () => {
  if (!availableSpotsInput.dataset.manuallyEdited) {
    availableSpotsInput.value = capacityInput.value;
  }
});
```

**Edit Form** (T088):
```javascript
// NO auto-sync - bookings may exist
// Admin must manually adjust both fields
```

**Why**:

Example:
- Capacity: 100, Available: 75, Booked: 25
- Admin increases capacity to 150
- With auto-sync: Available → 150 (WRONG! 75 phantom bookings)
- Without auto-sync: Available stays 75, admin sets to 125 (CORRECT)

### Preserve Relationships

**Before Updating**:
```typescript
// Check for dependent records
const bookings = await getBookingsForEvent(eventId);

if (bookings.length > 0 && newCapacity < bookings.length) {
  throw new Error(`Cannot reduce capacity below ${bookings.length} (existing bookings)`);
}
```

**Warn User**:
```typescript
if (newCapacity < oldCapacity) {
  const message = `Reducing capacity from ${oldCapacity} to ${newCapacity}. This may affect bookings.`;
  showWarning(message);
}
```

---

## 7. Validation with Existing Data {#validation}

### Consider Current State

**Capacity Validation**:

**Create Form**:
```typescript
// Simple: available <= capacity
if (availableSpots > capacity) {
  return 'Available spots cannot exceed capacity';
}
```

**Edit Form**:
```typescript
// Complex: consider bookings
const bookedSpots = capacity - availableSpots;

if (newCapacity < bookedSpots) {
  return `Capacity cannot be less than ${bookedSpots} (existing bookings)`;
}

if (newAvailableSpots > newCapacity) {
  return 'Available spots cannot exceed capacity';
}
```

### Unique Constraint Validation

**Slug Uniqueness**:
```typescript
// Allow current slug (editing same resource)
const existingSlug = await findResourceBySlug(newSlug);

if (existingSlug && existingSlug.id !== currentResourceId) {
  return 'This slug is already in use by another resource';
}
```

**Why Check ID**:
- Editing resource may keep same slug
- Only error if slug belongs to *different* resource

### Date Range Validation

**Event Date**:

**Create Form**:
```typescript
if (eventDate < new Date()) {
  return 'Event date must be in the future';
}
```

**Edit Form**:
```typescript
// Allow editing past events (for historical records)
// But warn user
if (eventDate < new Date()) {
  showWarning('This event is in the past. Are you sure you want to update it?');
}
```

### Cross-Field Validation

```typescript
function validateForm(data: FormData): string[] {
  const errors: string[] = [];
  
  const startDate = new Date(data.get('start_date'));
  const endDate = new Date(data.get('end_date'));
  
  if (endDate < startDate) {
    errors.push('End date must be after start date');
  }
  
  const capacity = parseInt(data.get('capacity'));
  const availableSpots = parseInt(data.get('available_spots'));
  
  if (availableSpots > capacity) {
    errors.push('Available spots cannot exceed capacity');
  }
  
  return errors;
}
```

---

## 8. API Update Patterns {#api-updates}

### PUT vs PATCH

**PUT** - Full replacement:
```typescript
// Replace entire resource
PUT /api/resources/:id
{
  // All fields required
  title: "New Title",
  description: "New Description",
  price: 99.99,
  ...
}
```

**PATCH** - Partial update:
```typescript
// Update only specified fields
PATCH /api/resources/:id
{
  // Only changed fields
  title: "New Title",
  price: 99.99
}
```

**When to Use**:
- **PUT**: Form updates all fields (most common)
- **PATCH**: Toggle switches, quick edits, API endpoints

### API Request Pattern

```typescript
const eventId = form.dataset.eventId;

const response = await fetch(`/api/admin/events/${eventId}`, {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(data),
});

if (!response.ok) {
  const error = await response.json();
  throw new Error(error.error || 'Failed to update');
}

const result = await response.json();
```

### Optimistic Updates

**Pattern**:
```typescript
// 1. Update UI immediately
updateUIWithNewData(data);

// 2. Send request
try {
  await updateResource(id, data);
  // Success - UI already updated
} catch (error) {
  // Revert UI
  revertUIToOldData(oldData);
  showError(error);
}
```

**When to Use**:
- Fast-feeling UX
- Low risk of failure
- Easy to revert

**When NOT to Use**:
- Complex validation
- High risk operations
- Hard to revert (e.g., payments)

---

## 9. Error Handling {#error-handling}

### Multi-Level Error Handling

#### 1. SSR Level (Data Fetch)

```typescript
try {
  resource = await getResourceById(id);
} catch (error) {
  if (error instanceof NotFoundError) {
    return Astro.redirect('/admin/resources?error=not_found');
  }
  
  if (error instanceof UnauthorizedError) {
    return Astro.redirect('/login?error=unauthorized');
  }
  
  console.error('Unexpected error:', error);
  return Astro.redirect('/admin/resources?error=server_error');
}
```

**User Sees**: Redirect to list page with error message

#### 2. Client Validation Level

```typescript
form.addEventListener('submit', async (e) => {
  e.preventDefault();
  
  // Validate required fields
  const errors = validateForm(form);
  
  if (errors.length > 0) {
    showErrors(errors);
    focusFirstError();
    return; // Stop submission
  }
  
  // Continue with API request
});
```

**User Sees**: Red borders, error messages, focus moved

#### 3. API Request Level

```typescript
try {
  const response = await fetch(url, options);
  
  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || 'Failed to update');
  }
  
  // Success
} catch (error) {
  if (error instanceof TypeError) {
    // Network error
    toast.error('Network error. Please check your connection.');
  } else {
    // API error
    toast.error(error.message);
  }
}
```

**User Sees**: Toast notification with specific error

#### 4. Network/Unexpected Level

```typescript
window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection:', event.reason);
  toast.error('Something went wrong. Please try again.');
});
```

**User Sees**: Generic error toast

### Error Display Patterns

**Inline Error**:
```html
<input 
  type="text"
  name="email"
  aria-invalid="true"
  aria-describedby="email-error"
/>
<p id="email-error" class="text-red-600 text-sm">
  Please enter a valid email address
</p>
```

**Toast Notification**:
```typescript
toast.error('Failed to update event', {
  duration: 5000,
  position: 'top-right',
});
```

**Modal Dialog**:
```typescript
showConfirmDialog({
  title: 'Error Updating Event',
  message: 'The event could not be updated. Would you like to try again?',
  buttons: [
    { label: 'Retry', action: () => retrySubmit() },
    { label: 'Cancel', action: () => {} },
  ],
});
```

---

## 10. Testing Edit Forms {#testing}

### Key Test Categories

#### 1. Data Pre-filling Tests

```typescript
describe('Pre-filling Form Fields', () => {
  it('should handle string price conversion for input value', () => {
    const stringPrice = '99.99';
    const numberPrice = 99.99;
    
    expect(parseFloat(stringPrice)).toBe(numberPrice);
  });

  it('should format existing date for datetime-local input', () => {
    const date = new Date('2024-12-15T18:30:00Z');
    const formatted = formatDateTimeLocal(date);
    
    expect(formatted).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/);
  });
  
  it('should handle optional coordinates', () => {
    expect(parseOptionalNumber(undefined)).toBeUndefined();
    expect(parseOptionalNumber('37.7749')).toBe(37.7749);
    expect(parseOptionalNumber(null)).toBeUndefined();
  });
});
```

#### 2. Smart Logic Tests

```typescript
describe('Conditional Slug Generation', () => {
  it('should update slug when it matches auto-generated pattern', () => {
    const previousTitle = 'Yoga Session';
    const currentSlug = 'yoga-session'; // Auto-generated
    const newTitle = 'Advanced Yoga';
    
    const shouldUpdate = shouldAutoUpdateSlug(currentSlug, previousTitle, newTitle);
    expect(shouldUpdate).toBe(true);
  });
  
  it('should NOT update custom slug', () => {
    const previousTitle = 'Yoga Session';
    const currentSlug = 'special-yoga'; // Custom
    const newTitle = 'Advanced Yoga';
    
    const shouldUpdate = shouldAutoUpdateSlug(currentSlug, previousTitle, newTitle);
    expect(shouldUpdate).toBe(false);
  });
});
```

#### 3. Validation Tests

```typescript
describe('Edit Form Validation', () => {
  it('should allow capacity increase with existing bookings', () => {
    const oldCapacity = 100;
    const bookedSpots = 25;
    const newCapacity = 150;
    const newAvailable = 125; // 150 - 25
    
    expect(validateCapacity(newCapacity, newAvailable)).toBe(true);
  });
  
  it('should reject capacity below existing bookings', () => {
    const bookedSpots = 25;
    const newCapacity = 20; // Less than bookings!
    
    expect(validateCapacity(newCapacity, 0)).toBe(false);
  });
});
```

#### 4. Type Conversion Tests

```typescript
describe('Data Formatting for API', () => {
  it('should convert form strings to proper types', () => {
    const formData = {
      price: '99.99',
      capacity: '50',
      duration: '2',
      is_published: 'on',
    };
    
    const formatted = formatForAPI(formData);
    
    expect(typeof formatted.price).toBe('number');
    expect(formatted.price).toBe(99.99);
    expect(typeof formatted.capacity).toBe('number');
    expect(formatted.is_published).toBe(true);
  });
});
```

---

## 11. Best Practices {#best-practices}

### 1. Always Fetch Fresh Data

**❌ Bad**:
```typescript
// Using stale data from list page
const resource = Astro.locals.resource; // May be cached
```

**✅ Good**:
```typescript
// Always fetch fresh data
const resource = await getResourceById(id);
```

**Why**: Data may have changed since list page was rendered

### 2. Handle All Type Variations

**❌ Bad**:
```html
<input value={resource.price} />
```

**✅ Good**:
```html
<input value={typeof resource.price === 'string' ? parseFloat(resource.price) : resource.price} />
```

**Why**: Database drivers return different types

### 3. Provide Context in Error Messages

**❌ Bad**:
```typescript
toast.error('Update failed');
```

**✅ Good**:
```typescript
toast.error(`Failed to update "${resource.title}". ${error.message}`);
```

**Why**: User knows which resource and why it failed

### 4. Preserve User Input on Validation Failure

**❌ Bad**:
```typescript
// On validation error, page reloads and loses input
return Astro.redirect('/edit?error=validation');
```

**✅ Good**:
```typescript
// Client-side validation - input preserved
form.addEventListener('submit', (e) => {
  if (!validate()) {
    e.preventDefault(); // Stop submission, keep input
    showErrors();
  }
});
```

### 5. Show What Changed

**Enhanced UX**:
```typescript
// Track original values
const original = { ...resource };

// On submit, show diff
const changes = getChangedFields(original, newData);

if (changes.length === 0) {
  toast.info('No changes made');
  return;
}

toast.success(`Updated: ${changes.join(', ')}`);
```

### 6. Warn About Destructive Actions

**Capacity Reduction**:
```typescript
if (newCapacity < oldCapacity && bookedSpots > 0) {
  const proceed = await showConfirmDialog({
    title: 'Reduce Capacity?',
    message: `This may affect ${bookedSpots} existing bookings. Continue?`,
  });
  
  if (!proceed) return;
}
```

### 7. Provide Helpful Defaults

**Date Fields**:
```typescript
// If event date is past, suggest today + 7 days
if (resource.event_date < new Date()) {
  const suggestedDate = new Date();
  suggestedDate.setDate(suggestedDate.getDate() + 7);
  
  showInfo(`Event is in the past. Suggest: ${formatDate(suggestedDate)}`);
}
```

### 8. Test with Real Data

**Test Cases**:
- Empty optional fields
- Maximum length strings
- Edge case numbers (0, negative, very large)
- Past dates
- Future dates far in future
- Special characters in strings
- Unicode characters
- Malformed data

### 9. Make Forms Accessible

**Checklist**:
- [ ] All inputs have labels
- [ ] Required fields marked with asterisk
- [ ] Error messages use `aria-invalid` and `aria-describedby`
- [ ] Focus moves to first error
- [ ] Keyboard navigation works
- [ ] Form can be submitted with Enter key
- [ ] Cancel can be triggered with Escape key

### 10. Optimize Performance

**Large Forms**:
```typescript
// Debounce auto-save
let saveTimer: number;

form.addEventListener('input', () => {
  clearTimeout(saveTimer);
  saveTimer = setTimeout(() => {
    autoSave(form);
  }, 2000); // Save 2 seconds after user stops typing
});
```

**Large Datasets**:
```typescript
// Load related data only when needed
<details>
  <summary>Advanced Options</summary>
  <div hx-get="/api/advanced-options" hx-trigger="revealed">
    <!-- Loaded when expanded -->
  </div>
</details>
```

---

## Summary

### Key Takeaways

1. **Edit Forms are Different**:
   - Pre-fill data from server
   - Handle type conversions
   - Conditional smart features
   - Validate against existing state

2. **Data Fetching**:
   - Always fetch fresh data during SSR
   - Handle errors with user-friendly redirects
   - Authenticate before fetching

3. **Pre-filling**:
   - Handle string/number type variations
   - Format dates for HTML inputs
   - Convert arrays to strings
   - Set checkbox/radio states

4. **Smart Features**:
   - Auto-generate only when appropriate
   - Don't auto-sync fields with existing state
   - Preserve relationships and bookings

5. **Validation**:
   - Consider existing data constraints
   - Validate unique fields (except current resource)
   - Warn about destructive changes
   - Show specific, actionable errors

6. **API Updates**:
   - Use PUT for full updates
   - Use PATCH for partial updates
   - Format data correctly for API
   - Handle success and errors gracefully

### Practice Exercises

1. **Convert a create form to edit form**
2. **Add date formatting** to existing edit form
3. **Implement conditional slug updates**
4. **Add optimistic updates** to form
5. **Create comprehensive test suite** for edit form

---

## Related Resources

- **MDN**: FormData API, Fetch API
- **TypeScript**: Type guards and type conversion
- **Astro**: SSR patterns, error handling
- **Accessibility**: WCAG form guidelines
- **T088**: Event edit form implementation
- **T087**: Event create form (comparison)
- **T068**: Course edit form (pattern reference)

---

**Remember**: Edit forms require more care than create forms. Always validate fresh data, respect existing relationships, and provide clear feedback to users about what changed and why operations failed.
